#!/usr/bin/ruby
# -*- coding: utf-8 -*-
#
# Check whether macros generated by mockgen.rb replace
# symbols in the files ../test*/*.[ch]pp

require_relative './mockgenConst.rb'
require_relative './mockgenCommon.rb'

# Filenames before preprocessing (dirs excluded)
CHECKED_HEADER_FILENAME = "mockgenSample2.hpp"
CHECKED_SOURCE_FILENAME = "mockgenSampleUser.cpp"

# Filenames after preprocessing (including dirs)
INPUT_SOURCE_FILENAME_SET = [
  "obj/mockgenSampleUser.processed",
  "obj/mockgenSampleTestBody.processed"
]

# Words that preprocessors replace
SWAPPED_TO_DECORATOR = ["DerivedClass", "ConstructorWithArg", "TopLevelClass"]
SWAPPED_TO_FORWARDER = ["anObject", "aCtorWithArg", "aTopLevelObject"]

# Map from filenames to replaced words
CHECKED_FILE_SET = {
  CHECKED_HEADER_FILENAME => SWAPPED_TO_DECORATOR,
  CHECKED_SOURCE_FILENAME => [SWAPPED_TO_DECORATOR, SWAPPED_TO_FORWARDER].flatten
}

# Texts of check results to display
TEXT_RESULT_SET = {false => "failed", true => "passed" }

# Symbols in a .hpp/.cpp file that preprocessors replace
class CppSymbolSet
  def initialize(filename, checkWordSet)
    @filename = filename
    @checkWordSet = checkWordSet
    @replacedWordSet = {}

    # Map of words before and after preprocess
    @checkWordSet.each do |word|
      # Assume [A-Z]* as types and [a-z] as variables
      suffix = /^[[:upper:]]/.match(word) ? Mockgen::Constants::CLASS_POSTFIX_DECORATOR : Mockgen::Constants::CLASS_POSTFIX_FORWARDER
      @replacedWordSet[word] = "::#{Mockgen::Constants::GENERATED_SYMBOL_NAMESPACE}::#{word}#{suffix}"
    end
  end

  # Check all lines in .hpp/.cpp files after preprocessing
  # Return true if all checks passes
  def check(lineSet)
    @checkCount = 0
    # note : all? uses short-circuit evaluation
    lineSet.reduce(true) { |result, line| result & checkLine(line) }
  end

  # Implementation detail
  # Check a line in .hpp/.cpp files after preprocessing
  # Return true if all checks passes
  def checkLine(line)
    # Collect candidates to be replaced
    wordSet = @checkWordSet.map { |word| line.include?(word) ? word : nil }.compact

    wordSet.reduce(true) do |resultAll, word|
      replacedWord = @replacedWordSet[word]
      result = line.include?(replacedWord)
      @checkCount += 1
      warn "> #{@filename}:\n  #{line}\n  #{replacedWord} should replace #{word}\n\n" unless result
      resultAll &= result
    end
  end

  # How many times checked?
  def getCheckCount
    # return nil if not checked
    @checkCount
  end
end

# Lines in a .hpp/.cpp file after preprocessing
class CppLineBlock
  attr_reader :filename, :lineSet

  # Parse the argument line such as '10 "dir/source.cpp" 2'
  def initialize(filenameLine)
    @lineSet = []
    @filename = getBasename(filenameLine)
  end

  def addLine(line)
    @lineSet << line if @filename
  end

  def valid?
    !(@filename.nil? || @lineSet.empty?)
  end

  # Implementation detail
  def getBasename(filenameLine)
    # Extract its full path name
    wordSet = filenameLine.split(/"/)
    return nil if (wordSet.size < 2)

    # Get its basename
    wordSet = wordSet[1].split(/[\\\/]+/)
    wordSet.empty? ? nil : wordSet[-1]

    # Invalidate self to reduce memory usage if the files is a system header
  end
end

# .hpp/.cpp file after preprocessing
class CppFile
  attr_reader :filename

  def initialize(filename)
    # Create a dummy block
    @filename = filename
    @lineBlock = CppLineBlock.new("")
    @allLineBlock = []

    # Throw file I/O exceptions
    File.open(filename, "r") { |file|
      readLines(file)
    }
  end

  def check(checkedFileSet)
    resultToReturn, checkCount = checkAllBlocks(checkedFileSet)

    if (checkCount == 0)
      warn "> #{@filename} : no words checked\n\n"
      resultToReturn = false
    end

    return resultToReturn, checkCount
  end

  ## Implementation detail
  def readLines(file)
    while rawLine = file.gets
      line = Mockgen::Common::LineWithoutCRLF.new(rawLine).line
      # Skip empty lines
      next unless md = line.match(/^\s*\S?/)

      # Remove leading and trailing spaces
      md = line.match(/^\s*(.*)\s*$/)
      sentence = md[1]
      parseLine(sentence)
    end

    # Add the last block in the file
    addLineBlock(nil)
  end

  def parseLine(line)
    if (line[0] == "#")
      # Filename found
      lineSet = CppLineBlock.new(line)
      addLineBlock(lineSet)
    else
      @lineBlock.addLine(line)
    end
  end

  def addLineBlock(lineBlock)
    @allLineBlock << @lineBlock if @lineBlock.valid?
    @lineBlock = lineBlock if lineBlock
  end

  def checkAllBlocks(checkedFileSet)
    checkCount = 0

    resultToReturn = @allLineBlock.reduce(true) do |resultAll, lineBlock|
      result = true
      filename = lineBlock.filename

      if checkedFileSet.key?(filename)
        wordSet = checkedFileSet[filename]
        lineSet = lineBlock.lineSet
        symbolSet = CppSymbolSet.new(filename, wordSet)
        result = symbolSet.check(lineSet)
        checkCount += symbolSet.getCheckCount
      end
      resultAll & result
    end

    return resultToReturn, checkCount
  end
end

# .hpp/.cpp files after preprocessing
class CppFileSet
  def initialize(args)
    filenameSet = (args.size) > 0 ? args : INPUT_SOURCE_FILENAME_SET
    @fileSet = parseFiles(filenameSet)
  end

  def parseFiles(cppFilenameSet)
    cppFilenameSet.map { |filename| CppFile.new(filename) }
  end

  def check
    @fileSet.each do |file|
      result, checkCount = file.check(CHECKED_FILE_SET)
      str = "#{file.filename} : #{TEXT_RESULT_SET[result]} (#{checkCount} checked)\n"
      puts str
    end
  end
end

CppFileSet.new(ARGV).check
